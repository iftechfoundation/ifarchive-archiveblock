/*
**  mod_archiveblock.c -- Apache archiveblock module
**  (Originally autogenerated via "apxs -n archiveblock -g". It's been
**  around the block a few times since then, though.)
**
**  Docs at: https://httpd.apache.org/docs/2.4/developer/modguide.html
**           https://httpd.apache.org/docs/2.4/programs/apxs.html
*/

#include "apr_escape.h"
#include "apr_strings.h"
#include "ap_config.h"
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"

static int archiveblock_handler(request_rec *r);
static const char *find_tags_for_uri(request_rec *r, int *redirect);
static apr_status_t check_config(const request_rec *r);
static apr_status_t read_config(const request_rec *r);
static void read_config_line(char *ln, const request_rec *r);

/* Struct for module configuration parameters */
typedef struct {
    const char *mappath;        /* path to the map file */
    const char *restrictdomain; /* domain to redirect to for geoblock check */
} archiveblock_config;

static archiveblock_config config;

/* Gotta thread-lock while accessing or loading the map file. */
static apr_thread_mutex_t *tagmap_lock = NULL;
static apr_time_t tagmap_mtime = 0;

/* Entries for individual files */
static apr_table_t *tagmap_files = NULL;
/* Entries that cover all the files in a directory */
static apr_table_t *tagmap_dirs = NULL;
/* Entries that cover all the files in a directory *tree* */
static apr_table_t *tagmap_trees = NULL;

/* Handler for setting the mappath. */
const char *archiveblock_set_map_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.mappath = arg;
    return NULL;
}

/* Handler for setting the restrictdomain. */
const char *archiveblock_set_restrict_domain(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.restrictdomain = arg;
    return NULL;
}

/* Apache module config directives. */
static const command_rec archiveblock_directives[] = {
    AP_INIT_TAKE1("ArchiveBlockMapPath", archiveblock_set_map_path, NULL, RSRC_CONF, "The path to the block map file."),
    AP_INIT_TAKE1("ArchiveBlockRestrictDomain", archiveblock_set_restrict_domain, NULL, RSRC_CONF, "The domain which handles tagged files."),
    { NULL }
};

/* Set up the Apache module callbacks.
 */
static void archiveblock_register_hooks(apr_pool_t *p)
{
    apr_status_t rc;

    /* Set default config parameters. */
    config.mappath = "/var/ifarchive/lib/blocktag.map";
    config.restrictdomain = "ukrestrict.ifarchive.org";

    rc = apr_thread_mutex_create(&tagmap_lock, APR_THREAD_MUTEX_DEFAULT, p);
    if (rc != APR_SUCCESS) {
        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, "ArchiveBlock: Unable to create thread lock");
    }
    
    tagmap_files = apr_table_make(p, 64);
    tagmap_dirs = apr_table_make(p, 64);
    tagmap_trees = apr_table_make(p, 64);
    
    ap_hook_handler(archiveblock_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* The request handler.
   We check the URI against our table of files (and directories) to block.
   If we find tags, add them as a X-IFArchive-Safety header, and then
   redirect to the ukrestrict domain (unless the request was already
   to that domain).
 */
static int archiveblock_handler(request_rec *r)
{
    if (strcmp(r->handler, "archiveblock")) {
        return DECLINED;
    }

    check_config(r);

    apr_finfo_t finfo;
    apr_status_t rc = apr_stat(&finfo, r->filename, APR_FINFO_TYPE, r->pool);
    if (rc != APR_SUCCESS || finfo.filetype != APR_REG) {
        /* File does not exist, or it's a directory. We don't restrict
           these; allow regular Apache handling to proceed.
           (If the file is a symlink to a restricted file, it should be
           listed in the map with the same tags as the destination.)
           (In practice we only apply this handler to regular files anyway,
           so as not to mess up Apache's autoindex module. So this test
           never fails.) */
        return DECLINED;
    }

    int redirect = FALSE;
    const char *tags = find_tags_for_uri(r, &redirect);
    if (!tags && !redirect) {
        /* No safety tags. Allow the regular Apache handling to proceed. */
        return DECLINED;
    }
    
    apr_table_add(r->headers_out, "X-IFArchive-Safety", tags);
    if (!redirect) {
        /* Tags, but not ones that are restricted in the UK. We let it
           proceed, except that we've added the X-IFArchive-Safety header.
           (Note that if the request winds up as an error, that
           header will be lost. But that's fine.) */
        return DECLINED;
    }

    if (!strcmp(r->hostname, config.restrictdomain)) {
        /* The request came to the ukrestrict domain. Again, let it
           proceed with the magic header. (UK geoblocking will happen
           at the Cloudflare level.) */
        return DECLINED;
    }

    /* We contruct our own 302-redirect response. (If we let Apache
       do it, it would lose our headers.) */

    /* Testing indicates we don't need to percent-encode r->uri. */
    const char *newurl = apr_psprintf(r->pool, "https://%s%s", config.restrictdomain, r->uri);
    
    apr_table_add(r->headers_out, "Location", newurl);
    apr_table_add(r->headers_out, "Access-Control-Allow-Origin", "*");

    r->status = 302;
    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "File tagged: %s\n", tags);
    ap_rprintf(r, "Redirecting to: %s\n", newurl);
    
    return OK;
}

/* See whether we have safety tags for the given request URI.
   If the tags include any that must be blocked in the UK, we also
   set *redirect.
*/
static const char *find_tags_for_uri(request_rec *r, int *redirect)
{
    const char *tags = NULL;
    const char *cx;

    tags = apr_table_get(tagmap_files, r->uri);
    
    if (!tags) {
        char *uri = apr_pstrdup(r->pool, r->uri);
        int len = strlen(uri);
        int backcount = 0;
        while (len >= 0) {
            while (len >= 1 && uri[len-1] != '/')
                len--;
            if (len <= 1)
                break;
            if (len) {
                uri[len-1] = '\0';
                len--;
                if (backcount == 0) {
                    tags = apr_table_get(tagmap_dirs, uri);
                    if (tags)
                        break;
                }
                tags = apr_table_get(tagmap_trees, uri);
                if (tags)
                    break;
                backcount++;
            }
            if (tags)
                break;
        }
    }

    /* An empty tags string means no tags. (Empty after the colon,
       in practice.) */
    if (!tags || *tags == '\0' || !strcmp(tags, ":")) {
        *redirect = FALSE;
        return NULL;
    }

    /* Advance past the "FLAG:" prefix. If we find a "u" flag, we're
       redirecting. */
    *redirect = FALSE;
    for (cx=tags; *cx && *cx != ':'; cx++) {
        if (*cx == 'u')
            *redirect = TRUE;
    }
    if (*cx == ':')
        cx++;

    return cx;
}

static int dump_func(void *rec, const char *key, const char *tags)
{
    const request_rec *r = rec;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "...%s: \"%s\"", key, tags);
    return TRUE;
}

/* Log the contents of the the tagmaps. For debug only. */
static void dump_tagmap(const request_rec *r)
{
    int count;
    
    count = apr_table_elts(tagmap_files)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "%d file entries:", count);
    apr_table_do(dump_func, (void *)r, tagmap_files, NULL);

    count = apr_table_elts(tagmap_dirs)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "%d dir entries:", count);
    apr_table_do(dump_func, (void *)r, tagmap_dirs, NULL);

    count = apr_table_elts(tagmap_trees)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "%d tree entries:", count);
    apr_table_do(dump_func, (void *)r, tagmap_trees, NULL);
}

/* Check if we need to reload the block file. If it's been updated since
   our last load, we reload it.
*/
static apr_status_t check_config(const request_rec *r)
{
    apr_status_t rc;
    apr_finfo_t finfo;
    
    rc = apr_thread_mutex_lock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to lock mutex");
        return rc;
    }

    rc = apr_stat(&finfo, config.mappath, APR_FINFO_MTIME, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to stat file: %s", config.mappath);
        apr_thread_mutex_unlock(tagmap_lock);
        return rc;
    }

    if (finfo.mtime > tagmap_mtime) {
        tagmap_mtime = finfo.mtime;
        rc = read_config(r);
        /* error already logged */
        if (FALSE)
            dump_tagmap(r);
    }

    rc = apr_thread_mutex_unlock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to unlock mutex");
        return rc;
    }

    return APR_SUCCESS;
}

#define BUFSIZE (256)

/* Read the block file into a table.
   (This must be called under the mutex.)
*/
static apr_status_t read_config(const request_rec *r)
{
    apr_status_t rc;
    apr_file_t *file = NULL;
    char buf[BUFSIZE];
    char *lbuf = NULL;
    apr_size_t lbufsize, lbuflen;

    /* Note that the tagmap table is allocated from the server pool, but
       our temporary workspace for reading is allocated from the
       connection. */

    lbufsize = 2*BUFSIZE;
    lbuflen = 0;
    lbuf = apr_palloc(r->pool, lbufsize+1);
    if (!lbuf) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to allocate %ld bytes for buffer", lbufsize);
        return APR_ENOMEM;
    }
    
    rc = apr_file_open(&file, config.mappath, APR_READ, APR_OS_DEFAULT, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to open config: %s", config.mappath);
        return rc;
    }

    apr_table_clear(tagmap_files);
    apr_table_clear(tagmap_dirs);
    apr_table_clear(tagmap_trees);

    while (TRUE) {
        apr_size_t len = BUFSIZE;
        rc = apr_file_read(file, buf, &len);
        if (rc == APR_EOF) {
            break;
        }
        if (rc != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to read config: %s", config.mappath);
            apr_file_close(file);
            return rc;
        }

        if (lbuflen + len > lbufsize) {
            lbufsize = (lbuflen + len) * 2;
            char *newlbuf = apr_palloc(r->pool, lbufsize+1);
            if (!newlbuf) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "ArchiveBlock: Unable to allocate %ld bytes for buffer", lbufsize);
                apr_file_close(file);
                return rc;
            }

            memcpy(newlbuf, lbuf, lbuflen);
            lbuf = newlbuf;
            // allow the old lbuf to be cleaned up with the pool
        }

        memcpy(lbuf+lbuflen, buf, len);
        lbuflen += len;

        while (TRUE) {
            int ix;
            for (ix=0; ix<lbuflen; ix++) {
                if (lbuf[ix] == '\n') {
                    break;
                }
            }

            if (ix == lbuflen) {
                break;
            }

            lbuf[ix] = '\0';
            read_config_line(lbuf, r);
            memmove(lbuf, lbuf+ix+1, lbuflen-(ix+1));
            lbuflen -= (ix+1);
        }
    }

    if (lbuflen > 0) {
        lbuf[lbuflen] = '\0';
        read_config_line(lbuf, r);
    }

    apr_file_close(file);

    int filecount = apr_table_elts(tagmap_files)->nelts;
    int dircount = apr_table_elts(tagmap_dirs)->nelts;
    int treecount = apr_table_elts(tagmap_trees)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "ArchiveBlock: Read config: %d files, %d dirs, %d trees", filecount, dircount, treecount);
    
    return APR_SUCCESS;
}

/* Parse one line of the block file. Ignore blank lines and comments.
   This alters the line as it works. (Inserting nulls to break it up.)
   (This must be called under the mutex.)
*/
static void read_config_line(char *ln, const request_rec *r)
{
    char *cx = ln;
    char *key, *tags;

    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    if (!*cx)
        return;
    if (*cx == '#')
        return;

    key = cx;

    while (*cx && *cx != '\t')
        cx++;

    if (!*cx) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "unrecognized block line: %s", ln);
        return;
    }

    *cx = '\0';
    cx++;
    
    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    tags = cx;

    /* Right-strip whitespace. */
    int taglen = strlen(tags);
    while (taglen > 0 && (tags[taglen-1] == ' ' || tags[taglen-1] == '\t')) {
        tags[taglen-1] = '\0';
        taglen--;
    }

    /* Make sure the tags string contains a colon. */
    if (!strchr(tags, ':')) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "block line lacks colon: %s", tags);
        return;
    }

    /* If the key ends with slash-star, it's a dir entry. If it ends with
       slash-star-star, it's a subtree entry. If it ends with a bare slash
       somebody screwed up.
       In all these cases, we trim the slash-star marker. */
    int keylen = strlen(key);
    
    if (keylen > 1 && key[keylen-1] == '/') {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "block line ends with slash: %s", key);
    }
    else if (keylen > 2 && key[keylen-2] == '/' && key[keylen-1] == '*') {
        key[keylen-2] = '\0';
        apr_table_set(tagmap_dirs, key, tags);
    }
    else if (keylen > 3 && key[keylen-3] == '/' && key[keylen-2] == '*' && key[keylen-1] == '*') {
        key[keylen-3] = '\0';
        apr_table_set(tagmap_trees, key, tags);
    }
    else {
        apr_table_set(tagmap_files, key, tags);
    }
}

/* Apache module configuration. */
module AP_MODULE_DECLARE_DATA archiveblock_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    archiveblock_directives,     /* table of config file commands */
    archiveblock_register_hooks  /* register hooks  */
};

