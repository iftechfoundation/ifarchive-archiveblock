/*
**  mod_archiveblock.c -- Apache sample archiveblock module
**  [Autogenerated via ``apxs -n archiveblock -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_archiveblock.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /archiveblock in as follows:
**
**    #   httpd.conf
**    LoadModule archiveblock_module modules/mod_archiveblock.so
**    <Location /archiveblock>
**    SetHandler archiveblock
**    </Location>
**
**    Docs at: https://httpd.apache.org/docs/2.4/developer/modguide.html
**             https://httpd.apache.org/docs/2.4/programs/apxs.html
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"

static int archiveblock_handler(request_rec *r);
static apr_status_t check_config(const request_rec *r);
static apr_status_t read_config(const request_rec *r);
static void read_config_line(char *ln, const request_rec *r);

typedef struct {
    const char *mappath;
} archiveblock_config;

static archiveblock_config config;

static apr_thread_mutex_t *tagmap_lock = NULL;
static apr_table_t *tagmap = NULL;
static apr_time_t tagmap_mtime = 0;

const char *archiveblock_set_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.mappath = arg;
    return NULL;
}

static const command_rec archiveblock_directives[] = {
    AP_INIT_TAKE1("ArchiveBlockMapPath", archiveblock_set_path, NULL, RSRC_CONF, "The path to the block map."),
    { NULL }
};

static void archiveblock_register_hooks(apr_pool_t *p)
{
    apr_status_t rc;
    
    config.mappath = "/Users/zarf/Downloads/mod/archiveblock/blockmap";

    rc = apr_thread_mutex_create(&tagmap_lock, APR_THREAD_MUTEX_DEFAULT, p);
    if (rc != APR_SUCCESS) {
        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, "Unable to create thread lock");
    }
    
    tagmap = apr_table_make(p, 64);
    
    ap_hook_handler(archiveblock_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

static int archiveblock_handler(request_rec *r)
{
    if (strcmp(r->handler, "archiveblock")) {
        return DECLINED;
    }

    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "### config '%s'", config.mappath);
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "### filename '%s', uri '%s', path_info '%s'", r->filename, r->uri, r->path_info);

    //### works for DECLINED for file responses but not errors
    apr_table_add(r->headers_out, "X-Frotz", "maybe");

    check_config(r);

    //### apr_stat()

    if (strcmp(r->uri, "/block/test.html"))
        return DECLINED;
    
    r->content_type = "text/html";
    apr_table_add(r->headers_out, "X-Zarf", "yes");

    if (!r->header_only)
        ap_rputs("The sample page from mod_archiveblock.c\n", r);
    return OK;
}

static apr_status_t check_config(const request_rec *r)
{
    apr_status_t rc;
    apr_finfo_t finfo;
    
    rc = apr_thread_mutex_lock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to lock mutex");
        return rc;
    }

    rc = apr_stat(&finfo, config.mappath, APR_FINFO_MTIME, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to stat file: %s", config.mappath);
        apr_thread_mutex_unlock(tagmap_lock);
        return rc;
    }

    if (finfo.mtime > tagmap_mtime) {
        tagmap_mtime = finfo.mtime;
        rc = read_config(r);
        /* error already logged */
    }

    rc = apr_thread_mutex_unlock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to unlock mutex");
        return rc;
    }

    return APR_SUCCESS;
}

#define BUFSIZE (256)

static apr_status_t read_config(const request_rec *r)
{
    apr_status_t rc;
    apr_file_t *file = NULL;
    char buf[BUFSIZE];
    char *lbuf = NULL;
    apr_size_t lbufsize, lbuflen;

    /* Note that the tagmap table is allocated from the server pool, but
       our temporary workspace for reading is allocated from the
       connection. */

    lbufsize = 2*BUFSIZE;
    lbuflen = 0;
    lbuf = apr_palloc(r->pool, lbufsize+1);
    if (!lbuf) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to allocate %ld bytes for buffer", lbufsize);
        return APR_ENOMEM;
    }
    
    rc = apr_file_open(&file, config.mappath, APR_READ, APR_OS_DEFAULT, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to open config: %s", config.mappath);
        return rc;
    }

    while (TRUE) {
        apr_size_t len = BUFSIZE;
        rc = apr_file_read(file, buf, &len);
        if (rc == APR_EOF) {
            break;
        }
        if (rc != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to read config: %s", config.mappath);
            apr_file_close(file);
            return rc;
        }

        if (lbuflen + len > lbufsize) {
            lbufsize = (lbuflen + len) * 2;
            char *newlbuf = apr_palloc(r->pool, lbufsize+1);
            if (!newlbuf) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to allocate %ld bytes for buffer", lbufsize);
                apr_file_close(file);
                return rc;
            }

            memcpy(newlbuf, lbuf, lbuflen);
            lbuf = newlbuf;
            // allow the old lbuf to be cleaned up with the pool
        }

        memcpy(lbuf+lbuflen, buf, len);
        lbuflen += len;

        while (TRUE) {
            int ix;
            for (ix=0; ix<lbuflen; ix++) {
                if (lbuf[ix] == '\n') {
                    break;
                }
            }

            if (ix == lbuflen) {
                break;
            }

            lbuf[ix] = '\0';
            read_config_line(lbuf, r);
            memmove(lbuf, lbuf+ix+1, lbuflen-(ix+1));
            lbuflen -= (ix+1);
        }
    }

    if (lbuflen > 0) {
        lbuf[lbuflen] = '\0';
        read_config_line(lbuf, r);
    }

    apr_file_close(file);


    int count = apr_table_elts(tagmap)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "Read config, %d entries", count);
    
    return APR_SUCCESS;
}

static void read_config_line(char *ln, const request_rec *r)
{
    char *cx = ln;
    char *namex;

    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    if (!*cx)
        return;
    if (*cx == '#')
        return;

    namex = cx;

    while (*cx && *cx != '\t')
        cx++;

    if (!*cx) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "unrecognized block line: %s", ln);
        return;
    }

    *cx = '\0';
    cx++;
    
    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    apr_table_set(tagmap, namex, cx);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA archiveblock_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    archiveblock_directives,     /* table of config file commands */
    archiveblock_register_hooks  /* register hooks  */
};

