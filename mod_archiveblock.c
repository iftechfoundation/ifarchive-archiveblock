/*
**  mod_archiveblock.c -- Apache sample archiveblock module
**  [Autogenerated via ``apxs -n archiveblock -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_archiveblock.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /archiveblock in as follows:
**
**    #   httpd.conf
**    LoadModule archiveblock_module modules/mod_archiveblock.so
**    <Location /archiveblock>
**    SetHandler archiveblock
**    </Location>
**
**    Docs at: https://httpd.apache.org/docs/2.4/developer/modguide.html
**             https://httpd.apache.org/docs/2.4/programs/apxs.html
*/

#include "apr_escape.h"
#include "apr_strings.h"
#include "ap_config.h"
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"

static int archiveblock_handler(request_rec *r);
static apr_status_t check_config(const request_rec *r);
static apr_status_t read_config(const request_rec *r);
static void read_config_line(char *ln, const request_rec *r);

typedef struct {
    const char *mappath;
    const char *restrictdomain;
} archiveblock_config;

static archiveblock_config config;

static apr_thread_mutex_t *tagmap_lock = NULL;
static apr_table_t *tagmap = NULL;
static apr_time_t tagmap_mtime = 0;

const char *archiveblock_set_map_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.mappath = arg;
    return NULL;
}

const char *archiveblock_set_restrict_domain(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.restrictdomain = arg;
    return NULL;
}

static const command_rec archiveblock_directives[] = {
    AP_INIT_TAKE1("ArchiveBlockMapPath", archiveblock_set_map_path, NULL, RSRC_CONF, "The path to the block map."),
    AP_INIT_TAKE1("ArchiveBlockRestrictDomain", archiveblock_set_restrict_domain, NULL, RSRC_CONF, "The domain which handles tagged files."),
    { NULL }
};

static void archiveblock_register_hooks(apr_pool_t *p)
{
    apr_status_t rc;
    
    config.mappath = "/Users/zarf/Downloads/mod/archiveblock/blockmap";
    config.restrictdomain = "ukrestrict.ifarchive.org";

    rc = apr_thread_mutex_create(&tagmap_lock, APR_THREAD_MUTEX_DEFAULT, p);
    if (rc != APR_SUCCESS) {
        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, "Unable to create thread lock");
    }
    
    tagmap = apr_table_make(p, 64);
    
    ap_hook_handler(archiveblock_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

static int archiveblock_handler(request_rec *r)
{
    if (strcmp(r->handler, "archiveblock")) {
        return DECLINED;
    }

    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "### filename '%s', uri '%s', hostname '%s'", r->filename, r->uri, r->hostname);

    check_config(r);

    const char *tags = apr_table_get(tagmap, r->uri);
    if (!tags) {
        /* No safety tags. Allow the regular Apache handling to proceed. */
        return DECLINED;
    }
    
    apr_table_add(r->headers_out, "X-IFArchive-Safety", tags);

    if (!strcmp(r->hostname, config.restrictdomain)) {
        /* The request came to the ukrestrict domain. We let it proceed,
           except that we've added the X-IFArchive-Safety header.
           (Note that if the request winds up as an error, that
           header will be lost. But that's fine.) */
        return DECLINED;
    }

    /* We contruct our own 302-redirect response. (If we let Apache
       do it, it would lose our headers.) */

    /* Testing indicates we don't need to percent-encode r->uri. */
    const char *newurl = apr_psprintf(r->pool, "https://%s%s", config.restrictdomain, r->uri);
    
    apr_table_add(r->headers_out, "Location", newurl);
    apr_table_add(r->headers_out, "Access-Control-Allow-Origin", "*");

    r->status = 302;
    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "File tagged: %s\n", tags);
    ap_rprintf(r, "Redirecting to: %s\n", newurl);
    
    return OK;
}

static apr_status_t check_config(const request_rec *r)
{
    apr_status_t rc;
    apr_finfo_t finfo;
    
    rc = apr_thread_mutex_lock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to lock mutex");
        return rc;
    }

    rc = apr_stat(&finfo, config.mappath, APR_FINFO_MTIME, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to stat file: %s", config.mappath);
        apr_thread_mutex_unlock(tagmap_lock);
        return rc;
    }

    if (finfo.mtime > tagmap_mtime) {
        tagmap_mtime = finfo.mtime;
        rc = read_config(r);
        /* error already logged */
    }

    rc = apr_thread_mutex_unlock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to unlock mutex");
        return rc;
    }

    return APR_SUCCESS;
}

#define BUFSIZE (256)

static apr_status_t read_config(const request_rec *r)
{
    apr_status_t rc;
    apr_file_t *file = NULL;
    char buf[BUFSIZE];
    char *lbuf = NULL;
    apr_size_t lbufsize, lbuflen;

    /* Note that the tagmap table is allocated from the server pool, but
       our temporary workspace for reading is allocated from the
       connection. */

    lbufsize = 2*BUFSIZE;
    lbuflen = 0;
    lbuf = apr_palloc(r->pool, lbufsize+1);
    if (!lbuf) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to allocate %ld bytes for buffer", lbufsize);
        return APR_ENOMEM;
    }
    
    rc = apr_file_open(&file, config.mappath, APR_READ, APR_OS_DEFAULT, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to open config: %s", config.mappath);
        return rc;
    }

    while (TRUE) {
        apr_size_t len = BUFSIZE;
        rc = apr_file_read(file, buf, &len);
        if (rc == APR_EOF) {
            break;
        }
        if (rc != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to read config: %s", config.mappath);
            apr_file_close(file);
            return rc;
        }

        if (lbuflen + len > lbufsize) {
            lbufsize = (lbuflen + len) * 2;
            char *newlbuf = apr_palloc(r->pool, lbufsize+1);
            if (!newlbuf) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to allocate %ld bytes for buffer", lbufsize);
                apr_file_close(file);
                return rc;
            }

            memcpy(newlbuf, lbuf, lbuflen);
            lbuf = newlbuf;
            // allow the old lbuf to be cleaned up with the pool
        }

        memcpy(lbuf+lbuflen, buf, len);
        lbuflen += len;

        while (TRUE) {
            int ix;
            for (ix=0; ix<lbuflen; ix++) {
                if (lbuf[ix] == '\n') {
                    break;
                }
            }

            if (ix == lbuflen) {
                break;
            }

            lbuf[ix] = '\0';
            read_config_line(lbuf, r);
            memmove(lbuf, lbuf+ix+1, lbuflen-(ix+1));
            lbuflen -= (ix+1);
        }
    }

    if (lbuflen > 0) {
        lbuf[lbuflen] = '\0';
        read_config_line(lbuf, r);
    }

    apr_file_close(file);


    int count = apr_table_elts(tagmap)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "Read config, %d entries", count);
    
    return APR_SUCCESS;
}

static void read_config_line(char *ln, const request_rec *r)
{
    char *cx = ln;
    char *namex;

    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    if (!*cx)
        return;
    if (*cx == '#')
        return;

    namex = cx;

    while (*cx && *cx != '\t')
        cx++;

    if (!*cx) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "unrecognized block line: %s", ln);
        return;
    }

    *cx = '\0';
    cx++;
    
    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    apr_table_set(tagmap, namex, cx);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA archiveblock_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    archiveblock_directives,     /* table of config file commands */
    archiveblock_register_hooks  /* register hooks  */
};

