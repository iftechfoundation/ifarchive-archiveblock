/*
**  mod_archiveblock.c -- Apache sample archiveblock module
**  [Autogenerated via ``apxs -n archiveblock -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_archiveblock.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /archiveblock in as follows:
**
**    #   httpd.conf
**    LoadModule archiveblock_module modules/mod_archiveblock.so
**    <Location /archiveblock>
**    SetHandler archiveblock
**    </Location>
**
**    Docs at: https://httpd.apache.org/docs/2.4/developer/modguide.html
**             https://httpd.apache.org/docs/2.4/programs/apxs.html
*/

#include "apr_escape.h"
#include "apr_strings.h"
#include "ap_config.h"
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"

static int archiveblock_handler(request_rec *r);
static const char *find_tags_for_uri(request_rec *r, int *redirect);
static apr_status_t check_config(const request_rec *r);
static apr_status_t read_config(const request_rec *r);
static void read_config_line(char *ln, const request_rec *r);

typedef struct {
    const char *mappath;
    const char *restrictdomain;
} archiveblock_config;

static archiveblock_config config;

static apr_thread_mutex_t *tagmap_lock = NULL;
static apr_time_t tagmap_mtime = 0;

/* Entries for individual files */
static apr_table_t *tagmap_files = NULL;
/* Entries that cover all the files in a directory */
static apr_table_t *tagmap_dirs = NULL;
/* Entries that cover all the files in a directory *tree* */
static apr_table_t *tagmap_trees = NULL;

/* Handler for setting the mappath. */
const char *archiveblock_set_map_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.mappath = arg;
    return NULL;
}

/* Handler for setting the restrictdomain. */
const char *archiveblock_set_restrict_domain(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.restrictdomain = arg;
    return NULL;
}

/* Apache module config directives. */
static const command_rec archiveblock_directives[] = {
    AP_INIT_TAKE1("ArchiveBlockMapPath", archiveblock_set_map_path, NULL, RSRC_CONF, "The path to the block map."),
    AP_INIT_TAKE1("ArchiveBlockRestrictDomain", archiveblock_set_restrict_domain, NULL, RSRC_CONF, "The domain which handles tagged files."),
    { NULL }
};

/* Set up the Apache module callbacks.
 */
static void archiveblock_register_hooks(apr_pool_t *p)
{
    apr_status_t rc;
    
    config.mappath = "/Users/zarf/Downloads/mod/archiveblock/blockmap";
    config.restrictdomain = "ukrestrict.ifarchive.org";

    rc = apr_thread_mutex_create(&tagmap_lock, APR_THREAD_MUTEX_DEFAULT, p);
    if (rc != APR_SUCCESS) {
        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, "Unable to create thread lock");
    }
    
    tagmap_files = apr_table_make(p, 64);
    tagmap_dirs = apr_table_make(p, 64);
    tagmap_trees = apr_table_make(p, 64);
    
    ap_hook_handler(archiveblock_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* The request handler.
   We check the URI against our table of files (and directories) to block.
   If we find tags, add them as a X-IFArchive-Safety header, and then
   redirect to the ukrestrict domain (unless the request was already
   to that domain).
 */
static int archiveblock_handler(request_rec *r)
{
    if (strcmp(r->handler, "archiveblock")) {
        return DECLINED;
    }

    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "### filename '%s', canon '%s', uri '%s', hostname '%s'", r->filename, r->canonical_filename, r->uri, r->hostname);

    check_config(r);

    apr_finfo_t finfo;
    apr_status_t rc = apr_stat(&finfo, r->filename, APR_FINFO_TYPE|APR_FINFO_LINK, r->pool);
    if (rc != APR_SUCCESS || finfo.filetype != APR_REG) {
        /* File does not exist, or it's a directory. We don't restrict
           these; allow regular Apache handling to proceed.
           (If the file is a symlink to a restricted file, it should be
           listed in the map with the same tags as the destination.) */
        return DECLINED;
    }

    int redirect = FALSE;
    const char *tags = find_tags_for_uri(r, &redirect);
    if (!tags && !redirect) {
        /* No safety tags. Allow the regular Apache handling to proceed. */
        return DECLINED;
    }
    
    apr_table_add(r->headers_out, "X-IFArchive-Safety", tags);
    if (!redirect) {
        /* Tags, but not ones that are restricted in the UK. We let it
           proceed, except that we've added the X-IFArchive-Safety header.
           (Note that if the request winds up as an error, that
           header will be lost. But that's fine.) */
        return DECLINED;
    }

    if (!strcmp(r->hostname, config.restrictdomain)) {
        /* The request came to the ukrestrict domain. Again, let it
           proceed with the magic header. (UK geoblocking will happen
           at the Cloudflare level.) */
        return DECLINED;
    }

    /* We contruct our own 302-redirect response. (If we let Apache
       do it, it would lose our headers.) */

    /* Testing indicates we don't need to percent-encode r->uri. */
    const char *newurl = apr_psprintf(r->pool, "https://%s%s", config.restrictdomain, r->uri);
    
    apr_table_add(r->headers_out, "Location", newurl);
    apr_table_add(r->headers_out, "Access-Control-Allow-Origin", "*");

    r->status = 302;
    ap_set_content_type(r, "text/plain");
    ap_rprintf(r, "File tagged: %s\n", tags);
    ap_rprintf(r, "Redirecting to: %s\n", newurl);
    
    return OK;
}

/* See whether we have safety tags for the given request URI.
   If the tags include any that must be blocked in the UK, we also
   set *redirect.
*/
static const char *find_tags_for_uri(request_rec *r, int *redirect)
{
    const char *tags = NULL;

    tags = apr_table_get(tagmap_files, r->uri);
    
    if (!tags) {
        char *uri = apr_pstrdup(r->pool, r->uri);
        int len = strlen(uri);
        int backcount = 0;
        while (len >= 0) {
            while (len >= 1 && uri[len-1] != '/')
                len--;
            if (len <= 1)
                break;
            if (len) {
                uri[len-1] = '\0';
                len--;
                if (backcount == 0) {
                    tags = apr_table_get(tagmap_dirs, uri);
                    if (tags)
                        break;
                }
                tags = apr_table_get(tagmap_trees, uri);
                if (tags)
                    break;
                backcount++;
            }
            if (tags)
                break;
        }
    }
    
    if (!tags) {
        *redirect = FALSE;
        return NULL;
    }

    *redirect = TRUE; //###
    return tags;
}

/* Check if we need to reload the block file. If it's been updated since
   our last load, we reload it.
*/
static apr_status_t check_config(const request_rec *r)
{
    apr_status_t rc;
    apr_finfo_t finfo;
    
    rc = apr_thread_mutex_lock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to lock mutex");
        return rc;
    }

    rc = apr_stat(&finfo, config.mappath, APR_FINFO_MTIME, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to stat file: %s", config.mappath);
        apr_thread_mutex_unlock(tagmap_lock);
        return rc;
    }

    if (finfo.mtime > tagmap_mtime) {
        tagmap_mtime = finfo.mtime;
        rc = read_config(r);
        /* error already logged */
    }

    rc = apr_thread_mutex_unlock(tagmap_lock);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to unlock mutex");
        return rc;
    }

    return APR_SUCCESS;
}

#define BUFSIZE (256)

/* Read the block file into a table.
   (This must be called under the mutex.)
*/
static apr_status_t read_config(const request_rec *r)
{
    apr_status_t rc;
    apr_file_t *file = NULL;
    char buf[BUFSIZE];
    char *lbuf = NULL;
    apr_size_t lbufsize, lbuflen;

    /* Note that the tagmap table is allocated from the server pool, but
       our temporary workspace for reading is allocated from the
       connection. */

    lbufsize = 2*BUFSIZE;
    lbuflen = 0;
    lbuf = apr_palloc(r->pool, lbufsize+1);
    if (!lbuf) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to allocate %ld bytes for buffer", lbufsize);
        return APR_ENOMEM;
    }
    
    rc = apr_file_open(&file, config.mappath, APR_READ, APR_OS_DEFAULT, r->pool);
    if (rc != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to open config: %s", config.mappath);
        return rc;
    }

    apr_table_clear(tagmap_files);
    apr_table_clear(tagmap_dirs);
    apr_table_clear(tagmap_trees);

    while (TRUE) {
        apr_size_t len = BUFSIZE;
        rc = apr_file_read(file, buf, &len);
        if (rc == APR_EOF) {
            break;
        }
        if (rc != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to read config: %s", config.mappath);
            apr_file_close(file);
            return rc;
        }

        if (lbuflen + len > lbufsize) {
            lbufsize = (lbuflen + len) * 2;
            char *newlbuf = apr_palloc(r->pool, lbufsize+1);
            if (!newlbuf) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Unable to allocate %ld bytes for buffer", lbufsize);
                apr_file_close(file);
                return rc;
            }

            memcpy(newlbuf, lbuf, lbuflen);
            lbuf = newlbuf;
            // allow the old lbuf to be cleaned up with the pool
        }

        memcpy(lbuf+lbuflen, buf, len);
        lbuflen += len;

        while (TRUE) {
            int ix;
            for (ix=0; ix<lbuflen; ix++) {
                if (lbuf[ix] == '\n') {
                    break;
                }
            }

            if (ix == lbuflen) {
                break;
            }

            lbuf[ix] = '\0';
            read_config_line(lbuf, r);
            memmove(lbuf, lbuf+ix+1, lbuflen-(ix+1));
            lbuflen -= (ix+1);
        }
    }

    if (lbuflen > 0) {
        lbuf[lbuflen] = '\0';
        read_config_line(lbuf, r);
    }

    apr_file_close(file);


    int filecount = apr_table_elts(tagmap_files)->nelts;
    int dircount = apr_table_elts(tagmap_dirs)->nelts;
    int treecount = apr_table_elts(tagmap_trees)->nelts;
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "Read config: %d files, %d dirs, %d trees", filecount, dircount, treecount);
    
    return APR_SUCCESS;
}

/* Parse one line of the block file. Ignore blank lines
   and comments.
   (This must be called under the mutex.)
*/
static void read_config_line(char *ln, const request_rec *r)
{
    char *cx = ln;
    char *key, *tags;

    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    if (!*cx)
        return;
    if (*cx == '#')
        return;

    key = cx;

    while (*cx && *cx != '\t')
        cx++;

    if (!*cx) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "unrecognized block line: %s", ln);
        return;
    }

    *cx = '\0';
    cx++;
    
    while (*cx && (*cx == ' ' || *cx == '\t'))
        cx++;

    tags = cx;

    /* Make sure the tags string contains a colon. */
    if (!strchr(tags, ':')) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "block line lacks colon: %s", tags);
        return;
    }

    /* If the key ends with slash-star, it's a dir entry. If it ends with
       slash-star-star, it's a subtree entry. If it ends with a bare slash
       somebody screwed up.
       In all these cases, we trim the slash-star marker. */
    int keylen = strlen(key);
    
    if (keylen > 1 && key[keylen-1] == '/') {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "block line ends with slash: %s", key);
    }
    else if (keylen > 2 && key[keylen-2] == '/' && key[keylen-1] == '*') {
        key[keylen-2] = '\0';
        apr_table_set(tagmap_dirs, key, tags);
    }
    else if (keylen > 3 && key[keylen-3] == '/' && key[keylen-2] == '*' && key[keylen-1] == '*') {
        key[keylen-3] = '\0';
        apr_table_set(tagmap_trees, key, tags);
    }
    else {
        apr_table_set(tagmap_files, key, tags);
    }
}

/* Apache module configuration. */
module AP_MODULE_DECLARE_DATA archiveblock_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    archiveblock_directives,     /* table of config file commands */
    archiveblock_register_hooks  /* register hooks  */
};

